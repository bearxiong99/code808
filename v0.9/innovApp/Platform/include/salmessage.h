#ifndef _SALMessage_H_
#define _SALMessage_H_

#include "libSAL.h"


#define KEY_HANDLE(key)			((int16_t)((key) >> 16))
#define KEY_QID(key)			((word_t)((key) & 0x0000FFFF))
#define MAKE_KEY(handle, qid)	((((int32_t)(handle)) << 16) | ((int32_t)(virtualQueueID)))


/**    @brief Message Passing

		SAL provides a communication model based on message passing that 
		supports intra- and inter-process communication as well as communication
		between different machines.
		A SAL message contains a header (carrying information to deliver messages 
		and to control their lifetime) and a data segment (carrying information
		that is delivered by the message). 
		
		The message format of SAL messages is defined in the following way:
		   - <b>Byte 1:</b> message type (if for example derivatives of SAL messages are used) 
		and the message priority (8 different priorities will be supported)
		   - <b>Byte 2:</b> header length (to determine the position of the first byte in the
		data segment. This gives flexibility to vary/extend the header information 
		if it is required
		   - <b>Bytes 3-6:</b> queue ID of the sender (to receive replies)
		   - <b>Bytes 7-10:</b> queue ID of the receiver. Queue identifiers can be understood 
		as symbolic names which are defined on a project base. They contain 
		information identifying which application and on which machine the queue is located.  
		   - <b>Bytes 11-14:</b> time stamp (denotes creation time of the message)
		   - <b>Bytes 15-16:</b> reference counter value (used to share a SAL message between 
		multiple clients without a need for copying) 
		   - <b>Bytes 17-20:</b> Message/event code (unique identifier of the message)
		   - <b>Bytes 21-24:</b> Magic cookie. A cookie is generated by the sender of a 
		message and is passed back to the sender in the reply message. It is not 
		allowed that the cookie is modified by the receiver. The pattern behind 
		this is named Asynchronous Continuation Token.
		   - <b>Bytes 25-26:</b> length of the data segment.
		   - <b>Bytes 27:</b> start of the message's data segment. The length of the data 
		segment is limited and has to be configured on a project base.

		<b>Note: The representation and order of the information presented above may
		change. It is not accessed directly but instead via the SALMessage wrapper
		class.</b>
		
		SAL messages are stored in a message pool that is created during application
		startup. By using reference counting a message in the pool can be shared
		by many clients and the number of copy operations is reduced. SAL relies on system-wide
		unique message identifiers in order to deliver messages in an efficient 
		way. Message identifiers are defined on a project base.
		
		The class SALMessage is a wrapper class that facilitates the creation as 
		well as read/write operations on the binary message representation stored
		in the pool. It allocates/deallocates a slot in the pool and handles the 
		messages reference count transparent to the user.

		The wrapper class SALMessage support sequential read/write operations:
		@code
		msg.seek(2); // position the read/write descriptor on the 3rd byte
		msg.setU8(0x25); // write the 3rd byte of the data sement
		msg.setU16(0x1966); // write the 4th and 5th bytes
		@endcode
		
		Direct read/write operation at certain position are supported as well:
		@code
		msg.setU8(0x25,4); // write value 0x25 into the 5th byte
		msg.setU16(0x66,2); // write value 0x66 into the 3rd byte
		@endcode
		
		For sending messages the following functions can be used:
		
		<b>Point-to-Point communication</b>
		@code
		bool sal_post ( SALMessage& msg, dword_t queueID );
		// Example:
		sal_post(msg,MSGQ_NAV_GC);
		@endcode

		<b>Broadcast Communication</b>
		@code
		bool sal_publish ( SALMessage& msg, bool mode=PUB_GLOBAL );
		bool sal_publishEvent ( uint32_t event, dword_t p1 = 0, dword_t p2 = 0 );
		bool sal_subscribeEvents ( int count, int evList[], dword_t queueID );
		bool sal_unsubscribeEvents ( int count, int evList[], dword_t queueID );
		// Examples:
		sal_publish(msg);
		sal_publish(msg,PUB_LOCAL); // intra-process only
		sal_publishEvent(EV_PWRON,(dword_t)this,(dword_t)cookie);
		sal_publishEvent(EV_PWRON,(dword_t)this);
		sal_publishEvent(EV_PWRON);
		@endcode
		
		
		
 */
class SALMessage
{
    friend class SALAbstractQueue;

public:
	/**
	 * Construct a message object without allocating a slot in the pool. This is
	 * a special constructor that is used for the message queue implementation
	 * @param mode true if a data segment is to be allocated
	 */
	SALMessage ( bool mode = true );
	
	/**
	 * Construct a message using the provided data. This constructor is when the 
	 * wrapper shall be placed around a just received binary message
	 */
	SALMessage ( const byte_t* rawData, int rawDataLen );

	/**
	 * This is the typical constructor that shall be used to create a message that
	 * shall be posted to a queue or that shall be published
	 * @param code event ID of the message to be sent
	 * @param rQueue ID of the receiver's queue
	 * @param sQueue ID of the sender's queue (used to send replies)
	 */
	SALMessage ( SALEventID code, dword_t rQueue=0, dword_t sQueue=0 );

	//! class destructor
	virtual ~SALMessage ( void );
	
	//! get the handle of the message that specifies a slot in the message pool
	int16_t getHandle ( void ) const;
	
	//! get the value of the sender field
	dword_t getSender ( void ) const;

	//! get the value of the receiver field
	dword_t getReceiver ( void ) const;
	
	//! return the message code
	SALEventID getID ( void ) const;
	
	//! serialize the message into a byte stream
	bool serialize ( void );
//	bool serialize ( byte_t* byteStream, word_t maxBytes );
	
	//! reconstruct the message data from a byte stream
	bool deserialize ( void );
//	bool deserialize ( byte_t* byteStream, word_t maxBytes );
	
	//! return the length of the message header
	int getHeaderLen ( void ) const;
	
	//! set the size of the data segment
	bool setDataLen ( word_t dataSize );
	
	//! return the length of the data segment
	int getDataLen ( void ) const;
	
	//! return length of the whole message
	int getRawDataLen ( void ) const;
	
	//! increment the reference counter
	void addReference ( void ) const;
	
	//! decrement the reference counter and release the memory buffer if refcount is zero
	void releaseReference ( void );
	
	//! seek a position in the data segment
	bool seek ( word_t position );
					
	/** add a byte to the data segment
	  * @param value data to store
	  * @param position to store data; -1 stores data in the current position, and the position is advanced
	  */
	bool setU8 ( byte_t value, int position = -1 );
	
	/** get a byte from the data segment
	  * @param position to retreive data; -1 indicates the current position,  and the position is advanced
	  */
	byte_t getU8 ( int position = -1 );
	
	/** add a word to the data segment
	  * @param value data to store
	  * @param position to store data; -1 stores data in the current position, and the position is advanced
	  */
	bool setU16 ( word_t value, int position = -1 );
	
	/** get a word from the data segment
	  * @param position to retreive data; -1 indicates the current position,  and the position is advanced
	  */
	word_t getU16 (int position = -1 );
	
	/** add a 32-bit dword to the data segment
	  * @param value data to store
	  * @param position to store data; -1 stores data in the current position, and the position is advanced
	  */
	bool setU32 ( dword_t value, int position = -1 );
	
	/** get a 32-bit dword from the data segment
	  * @param position to retreive data; -1 indicates the current position,  and the position is advanced
	  */
	dword_t getU32 ( int position = -1 );

	//! add a byte to the data segment
	bool setStream ( const byte_t* data, word_t dataSize, int position = -1 );
	
	//! add a byte to the data segment
	void getStream ( byte_t* data, word_t dataSize, int position = -1 );

	//! add a C-String to the data segment
	bool setCString ( const char *buffer, int position = -1 );

	//! get a C-String from the data segment
	void getCString ( char *buffer, int position = -1 );

    //! return a pointer to the first byte of the binary message representation
    byte_t* getRawPointer ( void ) const;
    
    //! return a pointer to the first byte of the data portion of the message
    byte_t* getDataPointer ( void ) const;
	
    word_t getVirtualQueueID ( void ) const {
    	return mVirtualQueueID;
    }
    
	int getPriority ( void ) const;

	void setPriority ( priority_t pPriority );
    

    
protected:
    bool adoptMessage ( int32_t key );
    
    void setVirtualQueueID ( word_t qid ) {
    	mVirtualQueueID = qid;
    }
    
protected:	
	//! handle of the message that specifies the slot in the pool. Not stored inside the pool
	int16_t  mHandle;		

	//! virtual queue identifier
	word_t  mVirtualQueueID;
		
	// raw message data (header plus data segment). points to a slot in the message pool
	SALRawMessage_t  mRawData;
	
	//! pointer the first byte of the data segment 
	byte_t*  mData;

	//! position of the write descriptor inside of the data segment 
	word_t  mPos;
};

#endif /*_SALMessage_H_*/
